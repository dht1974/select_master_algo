整个设计参考redis

采用一主多备方式，目前是一主两备

静态配置出一个master和两个slave，构成一个集群，并给集群起一个名字：te_group

启动顺序：先启动sentinel，再启动te_group

客户端启动过程：
1. 从配置文件中找的sentinel服务器广播消息的组播地址，需要加入的集群名称，集群名称全局唯一
   建议采用下面格式： function_{site_no}_{bus_no}_group 
   举例：te_1_10_group

2. 监听这个组播地址，可以得到当前需要加入集群的主节点，如果正好赶上主点发生故障而sentinel
   还没有识别出来，并且主点还活着并正常（投票机制，有可能大多数认为此master死掉了），那么
   等到sentinel发出新的主点后，客户端需要断开和老master的连接，并连接新的主点

3. 和主点的连接分为两种：控制指令连接和数据连接，控制指令优先级高不能混入数据连接中，有可能
   导致控制指令在数据量非常大的时候，处理不及时。

4. 通过控制连接发送登陆请求，请求里带上当前此客户端的唯一标识{group_id,dev_id}、接收断点、
   发送缓冲区当前缓存的数据范围（由于bus节点有可能进行主备切换，可能导致节点没有收到一下数据，
   发送段必须在内存里缓存一段时间的数据，直到总线的备节点发送出ACK后，才可以进行删除），总线
   主点收到登陆请求后，检查接收断点是否合理，比如是否超过当前最大可发送序号，由于总线上带有
   全局流水，因此只要小于最大可发送序号，就可以得到数据，但是如果主点需要非常多的数据，会严重
   影响主点的性能，因此在设计上主点都会采用一个滑动窗口，只有落在这个窗口内，主点才会为这个客户
   端补充流水，如果不在这个窗口的话，主点将发送一个应答，告诉客户端到哪个备节点进行流水恢复。
   如果主点发现没有备点了，就正常为客户端补流水。

   在生产上不会出现延迟加入的情况，但设计上需要有相应的机制，防止未来的异常情况。

5. 如果登陆出错，检测返回值，如果是需要到备点补充流水，那么建立到备点的连接，并且登陆备点。
   如果是其他错误，那么写日志，进程退出。

6. 当客户端从备点补流水完毕，完毕的标准是客户端进行判断的，主点的hello信息中会带有当前各个
   客户端所属组的最大接收序号，客户端可以根据这个序号，进行判断，只要在一定比较小范围内，就可以
   认为补流水完毕，断开和备点的连接。并立即建立和主点的数据连接，再次登陆。整个过程重复5,6，直到
   登陆成功，主点开始补发流水（也可能不用补）

7. 登陆时如果主点发现自己的接收断点，不在客户端的缓存范围内，拒绝登陆，本地写日志，并通知客户端。
   这种情况有可能出现在客户端重启动后，缓存的数据丢失，也可能出现在用新的客户端替换旧客户端时出现
   这种情况下，一般需要更好设备号，找一个全新设备号进行替换。

8. 客户端在发现主点发生切换的时候（监听sentinel消息），将首先断开和所有主点、备点的连接，进入等待
   等到选举结束、一切进入正轨后，连接主点，重复5,6操作。   


sentinel流程：参考redis sentinel，加入部分修改，redis sentinel选出的主点不能严格保证是流水最动的
   的节点，而我们需要严格选出，只有在同时出现两个点出错的情况下才会选举失败

1. sentinel根据配置，找到需要监控的组，有可能有多个组，根据配置建立和各个组主点的tcp通道，如果
   主点还未启动，一直尝试连接

2. 查询主点的备点信息，然后建立和所有备点的tcp通道，新节点加入组后，sentinel也需要建立和其的连接

3. 定时发送hello消息包，每个监控组处于不同的组播组中，相应的hello包也发到此组中。hello包中会携带有
   当前组的主点信息，此sentinel自己的信息，当前的epoch（界号）等信息。

4. 定时向组内的主、备点发送INFO查询包，组中的节点接受到这个查询包后，会将自己的一些信息上报，sentinel
   会在内存中维护每个节点的最新信息。

5. 异步接收INFO的返回信息，维护内存数据结构。

6. 定期发送ping包，客户端收到后立即发送pong包，里面不需要携带信息，ping包会发送的比较频繁，收到pong
   包后，要更新内存数据结构内的时间信息。

6. 根据内存数据结构维护的信息，定期查看是否有节点未更新时间超过down_after_period时间，如果超过，将
   此节点标记为 S_DOWN状态（主观down），并将这条信息发送给其他sentinel

